#!/usr/bin/python
# coding=UTF-8

# Model specification validation and processing:
# 1. Load model
# 2. Validate model for self-consistency and correctness
# 3. Convert model to documentation
# 4. Convert model to reference implementation

import os
import subprocess

class Shape:
    def __init__(self, text):
        self.id, self.name, self.dim, self.desc = text.split('\t')
        self.inherit = set()
        self.rep_in = set()
        self.rep_out = set()
        self.rep_canonical = None
        self.comment = ''
        self.inherit_comment = dict()

        if (self.id != 'ShapeID'):
            self.id = int(self.id)

    def check(self):
        if (self.name not in ['Scale', 'Grid', 'Text']):
            if self.rep_canonical == None:
                raise Exception('Shape ' + str(self.id) + ' has no canonical representation')

            if self.rep_canonical not in self.rep_in:
                raise Exception('Shape ' + str(self.id) + ' does not have the canonical representation as an input representation')

            if self.rep_canonical not in self.rep_out:
                raise Exception('Shape ' + str(self.id) + ' does not have the canonical representation as an output representation')

        return

    def reps(self):
        used = set()
        reps = dict()
        self.__reps(reps, used)

        return reps

    def __reps(self, reps, used):
        for r in self.rep_in | self.rep_out:
            if (r in reps):
                reps[r].add(self)
            else:
                reps[r] = set([self])
        used.add(self)
        for s in self.inherit:
            if (s not in used):
                s.__reps(reps, used)
        return

    def inherited(self):
        used = set()
        self.__inherited(used)
        used.remove(self)
        return used

    def __inherited(self, used):
        used.add(self)
        for s in self.inherit:
            if (s not in used):
                used.add(s)
                s.__inherited(used)

    # If we inherit a shape, we can use of all its in representations.
    def has_rep_in(self, rep):
        found = 0
        if rep in self.rep_in:
            found = 1
        else:
            for s in self.inherited():
                if s.__has_rep_in(rep):
                    found = 2
                    break
        return found

    def __has_rep_in(self, rep):
        found = 0
        if rep in self.rep_in:
            found = 1
        return found

    # If we inherit a shape, we can't necessarily use its out
    # representations (need to look up if that's possible using its in
    # representations directly).  i.e. we check if it inherits us (in
    # reverse)
    def has_rep_out(self, rep):
        found = 0
        if rep in self.rep_out:
            found = 1
        else:
            for s in self.inherited():
                if self in s.inherit and s.__has_rep_in(rep):
                    found = 2
                    break
        return found

    def __has_rep_out(self, rep):
        found = 0
        if rep in self.rep_out:
            found = 1
        return found

class Representation:
    def __init__(self, text):
        self.id, self.name, self.dim, self.desc = text.split('\t')
        self.members = dict()
        self.comment = ''

        if (self.id != 'RepID'):
            self.id = int(self.id)

    # Consistency check.  Make sure that sequence numbers are correct,
    # with no missing numbers.
    def check(self):
        print 'Checking ' + self.name + ':' + self.dim
        for member in self.members.values():
            member.check()

        s = set()
        for member in self.members.values():
            s.add(member.seq)

        if (len(s) == 0):
            raise Exception("No members for representation " + str(self.id))

        m = max(s)
        if (s != set(range(0,m+1))):
            raise Exception("Invalid sequence IDs for representation " + str(self.id))
        return

class RepresentationMember:
    def __init__(self, seq, name, type, desc):
        self.seq = seq
        self.name = name
        self.type = type
        self.desc = desc
        self.comment = ''

        self.seq = int(self.seq)

    def check(self):
        return

class Model:
    def __init__(self):
        self.shape_ids = dict()
        self.shape_names = dict()
        self.representation_ids = dict()
        self.representation_names = dict()

        self.load_shapes()
        self.load_reps()
        self.load_rep_members()
        self.load_shape_reps()
        self.load_shape_rels()
        self.check()

    def load_shapes(self):
        # Load shapes
        comment = ''
        for line in open ('spec/shapes.txt', 'rt'):
            line = line.rstrip('\n')
            if (len(line) == 0):
                continue
            if (line[0] == '#'):
                if (len(line) > 1 and line[1] == ' '):
                    comment += line[2:] + '\n'
                continue
            shape = Shape(line)
            if (len(comment) > 0):
                shape.comment = comment
                comment = ''
            if shape.id in self.shape_ids:
                raise Exception("Duplicate shape ID " + shape.id)
            self.shape_ids[shape.id] = shape
            if shape.name+':'+shape.dim in self.shape_names:
                raise Exception("Duplicate shape " + shape.name+':'+shape.dim)
            self.shape_names[shape.name+':'+shape.dim] = shape

        # TODO: Sort
        for shape in self.shape_ids.values():
            print shape.id, shape.name, shape.dim

    def load_reps(self):
        comment = ''
        # Load representations
        for line in open ('spec/representations.txt', 'rt'):
            line = line.rstrip('\n')
            if (len(line) == 0):
                continue
            if (line[0] == '#'):
                if (len(line) > 1 and line[1] == ' '):
                    comment += line[2:] + '\n'
                continue
            representation = Representation(line)
            if (len(comment) > 0):
                representation.comment = comment
                comment = ''
            if representation.id in self.representation_ids:
                raise Exception("Duplicate representation ID " + str(representation.id))
            self.representation_ids[representation.id] = representation
            if representation.name+':'+representation.dim in self.representation_names:
                raise Exception("Duplicate representation name+dim " + representation.name+':'+representation.dim)
            self.representation_names[representation.name+':'+representation.dim] = representation

        # TODO: Sort
        for representation in self.representation_ids.values():
            print representation.id, representation.name, representation.dim

        for key in self.representation_names.keys():
            print "KEY: " + key

    def load_rep_members(self):
        # Load representation members
        comment = ''
        for line in open ('spec/representationmembers.txt', 'rt'):
            line = line.rstrip('\n')
            if (len(line) == 0):
                continue
            if (line[0] == '#'):
                if (len(line) > 1 and line[1] == ' '):
                    comment += line[2:] + '\n'
                continue
            print line
            name, dim, memberseq, membername, membertype, memberdesc = line.split('\t')
            representation = self.representation_names[name+':'+dim]
            member = RepresentationMember(memberseq, membername, membertype, memberdesc)
            if (len(comment) > 0):
                member.comment = comment
                comment = ''
            if memberseq in representation.members:
                raise Exception("Duplicate representation " + str(representation.id) + " sequence " + str(memberseq))
            representation.members[memberseq] = member

    def load_shape_reps(self):
        # Load shape representations
        for line in open ('spec/shapereps.txt', 'rt'):
            line = line.rstrip('\n')
            if (len(line) == 0 or line[0] == '#'):
                continue
            shape, dim, rep, repdim, repin, repout, repcanonical, details = line.split('\t')
            if (shape == 'Shape'):
                continue
            s = self.shape_names[shape+':'+dim]
            srep = self.representation_names[rep+':'+repdim]
            if (repin == 'true'):
                s.rep_in.add(srep)
            if (repout == 'true'):
                s.rep_out.add(srep)
            if (repcanonical == 'true'):
                s.rep_canonical = srep

    def load_shape_rels(self):
        # Load shape relations
        comment = ''
        for line in open ('spec/shaperel.txt', 'rt'):
            line = line.rstrip('\n')
            if (len(line) == 0):
                continue
            if (line[0] == '#'):
                if (len(line) > 1 and line[1] == ' '):
                    comment += line[2:] + '\n'
                continue
            shape, dim, inherit, inheritdim = line.split('\t')
            if (shape == 'Shape'):
                continue
            s = self.shape_names[shape+':'+dim]
            si = self.shape_names[inherit+':'+inheritdim]
            s.inherit.add(si)
            if (len(comment) > 0):
                s.inherit_comment[inherit] = comment
                comment = ''

    def check(self):
        for shape in self.shape_ids.values():
            shape.check()
        for representation in self.representation_ids.values():
            representation.check()
        return

    def prepare_gen(self):
        if not os.path.exists("gen"):
            os.makedirs("gen")

    def shaperef(self, name, shape, dim):
        return ':ref:`' + name + ' <shape_' + shape + '_' + dim + '>`'

    def repref(self, name, rep, dim):
        return ':ref:`' + name + ' <rep_' + rep + '_' + dim + '>`'

    def dump_shapelist(self):
        self.prepare_gen()

        f = open('gen/shapes.txt','w')
        f.write("ID\tShape\tDims\tDescription\n")
        shapes = model.shape_ids.keys()
        shapes.sort()
        for id in shapes:
            shape = model.shape_ids[id]
            f.write(str(shape.id) + '\t:ref:`' + shape.name + ' <shape_' +
                    shape.name + '_' + shape.dim + '>`\t' +
                    shape.dim + '\t' + shape.desc + '\n')

    def dump_replist(self):
        self.prepare_gen()

        f = open('gen/representations.txt','w')
        f.write("ID\tRepresentation\tDims\tDescription\n")
        reps = model.representation_ids.keys()
        reps.sort()
        for id in reps:
            rep = model.representation_ids[id]
            f.write(str(rep.id) + '\t:ref:`' + rep.name + ' <rep_' +
                    rep.name + '_' + rep.dim + '>`\t' +
                    rep.dim + '\t' + rep.desc + '\n')

    def dump_shapereps(self):
        self.prepare_gen()

        shapes = model.shape_ids.keys()
        shapes.sort()
        shaperst = open('shapes.rst', 'w')
        print 'Writing shapes.rst'
        header = """Shapes
======

Overview
--------

.. tabularcolumns:: |r|l|l|p{3in}|
.. csv-table:: Shapes
    :header-rows: 1
    :file: gen/shapes.txt
    :delim: tab
    :widths: 2, 5, 2, 10

Definitions
-----------

Note that in the following tables, a ‘\•’ indicates a representation
implemented *directly* by a shape, while ‘*(\•)*’ indicates a
representation implemented *indirectly* through inheriting another
shape's representations for in (or vice-versa for out).

"""
        shaperst.write(header)
        for id in shapes:
            shape = model.shape_ids[id]
            filename = 'gen/shape-' + shape.name + '-' + shape.dim + '.txt'
            shapetab = open(filename, 'w')
            print 'Writing '+ filename
            shapetab.write('Representation\tDim\tIn\tOut\tInherited from\n')
            reps = shape.reps()
            replist = list(reps.keys())
            replist.sort(key = lambda x: x.name+':'+x.dim)

            for r in replist:
                repval = reps[r]
                canonical = (r == shape.rep_canonical)
                name = r.name
                if (canonical):
                    name = '**' + name + '**'
                repins = [x.name for x in shape.rep_in]
                rin = ('', '\•', '*(\•)*')[shape.has_rep_in(r)]
                rout = ('', '\•', '*(\•)*')[shape.has_rep_out(r)]
                ishapes = [x.name + ' (' + x.dim + ')' for x in reps[r]]
                ishapes.sort()
                # Make this shape name bold
                shapename = shape.name + ' (' + shape.dim + ')'
                for i in range(len(ishapes)):
                    if (ishapes[i] == shapename):
                        ishapes[i] = '**' + ishapes[i] + '** [self]'
                inherit = ', '.join(ishapes)

                shapetab.write(self.repref(r.name, r.name, r.dim) + '\t' + r.dim + '\t' +
                               rin + '\t' + rout + '\t' + inherit + '\n')
            shapetab.close()
            
            template = """
.. index::
    {0} ({1})

.. _shape_{0}_{1}:

{0} ({1})
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

{2}.

{3}

.. tabularcolumns:: |l|l|c|c|p{{3in}}|
.. csv-table:: {0} representations ({1})
    :header-rows: 1
    :file: {4}
    :delim: tab
    :widths: 5, 2, 2, 2, 10

"""
            shaperst.write(template.format(shape.name, shape.dim, shape.desc, shape.comment, filename))
            if (shape.rep_canonical):
                shaperst.write('Canonical form is ' + shape.rep_canonical.name + ' (' + shape.rep_canonical.dim + ').\n\n')

            # Sphinx definition
            clist = list(shape.inherit_comment.keys())
            clist.sort()
            for c in clist:
                comment = shape.inherit_comment[c]
                if (len(comment) > 0):
                    lines = comment.split('\n')
                    shaperst.write(c + '\n')
                    for line in lines:
                        shaperst.write('    ' + line + '\n')

        footer = """Relationships
-------------

The following figure illustrates the relationships detailed in the
above tables.  Ellipses are shapes, while representations are
rectangles.  Black arrows indicate inheritance of shape
representations, while red and blue arrows indicate the
representations possible to provide as input to and obtain as output
from a shape, respectively.

.. only:: html

    .. image:: gen/inherit.svg
        :width: 100%
	:alt: Graph of object relationships

.. only:: latex

    .. image:: gen/inherit.pdf
        :width: 100%
"""

        shaperst.write(footer)
        shaperst.close()
        return

    def dump_repmembers(self):
        self.prepare_gen()

        reps = model.representation_ids.keys()
        reps.sort()
        reprst = open('representations.rst', 'w')
        print 'Writing representations.rst'
        header="""Shape representations
=====================

Overview
--------

.. tabularcolumns:: |r|l|l|p{3.5in}|
.. csv-table:: Representations
    :header-rows: 1
    :file: gen/representations.txt
    :delim: tab
    :widths: 2, 5, 2, 10

Definitions
-----------

"""
        reprst.write(header)
        for id in reps:
            rep = model.representation_ids[id]
            filename = 'gen/rep-' + rep.name + '-' + rep.dim + '.txt'
            mtab = open(filename, 'w')
            print 'Writing ' + filename
            mtab.write('SeqNo\tName\tType\tDescription\n')
            members = rep.members
            mlist = list(members.keys())
            mlist.sort()

            for m in mlist:
                mval = members[m]
                mtab.write(str(mval.seq) + '\t' + mval.name + '\t' + mval.type + '\t' + mval.desc + '\n')
            mtab.close()

            template = """
.. index::
    {0} ({1})

.. _rep_{0}_{1}:

{0} ({1})
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

{2}.

{3}

.. tabularcolumns:: |r|l|l|p{{2in}}|
.. csv-table:: {0} members ({1})
    :header-rows: 1
    :file: {4}
    :delim: tab
    :widths: 2, 2, 5, 10

"""

            reprst.write(template.format(rep.name, rep.dim, rep.desc, rep.comment, filename))

            template = """
{0}
    {1}

"""

            # Sphinx definition
            for m in mlist:
                mval = members[m]
                if (len(mval.comment) > 0):
                    lines = mval.comment.split('\n')
                    reprst.write(mval.name + '\n')
                    for line in lines:
                        reprst.write('    ' + line + '\n')

        reprst.close()
        return

    def dump_relgraph(self):
        self.prepare_gen()

        dot = open('gen/inherit.dot', 'w')
        print 'Writing gen/inherit.dot'
        dot.write('digraph inheritance {\n')
#        dot.write('\tsize="4,8";\n')
        dot.write('\tnslimit=20;\n')
 #       dot.write('\tpage="6,8";\n')
#        dot.write('\tratio=fill;\n')
 #       dot.write('\taspect=0.75;')
        dot.write('\tmargin=0;\n')
        for rep in self.representation_ids.values():
            dot.write('\t"{0} ({1})" [shape=rectangle];\n'.format(rep.name, rep.dim))
        for shape in self.shape_ids.values():
            dot.write('\t"{0} ({1})" [shape=ellipse, style=filled, fillcolor="lightblue"];\n'.format(shape.name, shape.dim))
            for i in shape.inherit:
                dot.write('\t"{0} ({1})" -> "{2} ({3})";\n'.format(i.name, i.dim, shape.name, shape.dim))
            for r in shape.rep_in:
                dot.write('\t"{0} ({1})" -> "{2} ({3})" [color=red];\n'.format(r.name, r.dim, shape.name, shape.dim))
            for r in shape.rep_out:
                dot.write('\t"{0} ({1})" -> "{2} ({3})" [color=blue];\n'.format(shape.name, shape.dim, r.name, r.dim))
        dot.write('}\n')
        dot.close()
        print 'Generating gen/inherit.svg'
        subprocess.call(['sh', '-c', 'ccomps -x gen/inherit.dot | dot | gvpack -g | neato -n2 -Tsvg > gen/inherit.svg'])
        print 'Generating gen/inherit.pdf'
        subprocess.call(['sh', '-c', 'ccomps -x gen/inherit.dot | dot | gvpack -g | neato -n2 -Tpdf > gen/inherit.pdf'])
        return

if __name__ == "__main__":
    model = Model()

    model.dump_shapelist()
    model.dump_replist()
    model.dump_shapereps()
    model.dump_repmembers()
    model.dump_relgraph()
